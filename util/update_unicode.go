// Copyright Â© 2017 Phil Pennock.
// All rights reserved, except as granted under license.
// Licensed per file LICENSE.txt

// +build ignore

package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"

	// hrm, depending upon a package within which we're generating files
	"github.com/philpennock/character/unicode"

	"github.com/philpennock/character/internal/aux"
)

var flags struct {
	outDir             string
	unstable           bool
	minBlocksFetchSize uint64
	noFetch            bool
	packageName        string
	noFmt              bool
}
var warningCount int

const (
	stableUnicodeBaseURL   = "http://www.unicode.org/Public/UCD/latest/ucd/"
	unstableUnicodeBaseURL = "http://www.unicode.org/Public/10.0.0/ucd/"
	blocksFilename         = "Blocks.txt"
	unstableBlocksFilename = "Blocks-10.0.0d2.txt"
	blocksOutFilename      = "generated_blocks.go"
)

func init() {
	flag.StringVar(&flags.outDir, "output-dir", "unicode", "directory to create files in")
	flag.StringVar(&flags.packageName, "package", "unicode", "package to name generated files")
	flag.BoolVar(&flags.unstable, "unstable", false, "use latest draft Unicode we know of")
	flag.Uint64Var(&flags.minBlocksFetchSize, "min-blocks-fetchsize", 6*1024, "minimum size of Blocks.txt to not be an error")
	flag.BoolVar(&flags.noFetch, "no-fetch", false, "do not retrieve current files, regenerate from local only")
	flag.BoolVar(&flags.noFmt, "no-fmt", false, "do not run go fmt automatically")
}

func main() {
	flag.Parse()
	if v := os.Getenv("USE_UNPUBLISHED_UNICODE"); v != "" {
		flags.unstable = true
	}

	if !haveDir(flags.outDir) {
		Die("missing directory %q", flags.outDir)
	}

	var blocksURL string
	switch flags.unstable {
	case false:
		blocksURL = stableUnicodeBaseURL + blocksFilename
	case true:
		blocksURL = unstableUnicodeBaseURL + unstableBlocksFilename
	}
	blocksRawOutPath := filepath.Join(flags.outDir, blocksFilename)
	blocksGenOutPath := filepath.Join(flags.outDir, blocksOutFilename)

	if !flags.noFetch {
		if err := fetchURLtoFile(blocksURL, blocksRawOutPath); err != nil {
			Die("fetching %q from %q failed: %s", blocksRawOutPath, blocksURL, err)
		}
	}

	if err := generateBlocksFromTo(blocksRawOutPath, blocksGenOutPath); err != nil {
		Die("Generating %q from %q failed: %s", blocksGenOutPath, blocksRawOutPath, err)
	}

	if !flags.noFmt {
		if err := reformatFile(blocksGenOutPath); err != nil {
			Die("Running go fmt failed: %s", err)
		}
	}

	if warningCount > 0 {
		Warn("encountered %d warnings", warningCount)
		os.Exit(1)
	}
}

func fetchURLtoFile(url, outpath string) (err error) {
	out, err := os.Create(outpath)
	if err != nil {
		return err
	}
	defer func() {
		e := out.Close()
		if err == nil {
			err = e
		}
	}()
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	copied, err := io.Copy(out, resp.Body)
	if err != nil {
		return err
	}
	if copied < 0 || uint64(copied) < flags.minBlocksFetchSize {
		return fmt.Errorf("copied too little data, only %d octets, need at least %d", copied, flags.minBlocksFetchSize)
	}
	Trace("Updated %q from %q, size %d", outpath, url, copied)
	return nil
}

func generateBlocksFromTo(inFn, outFn string) error {
	in, err := os.Open(inFn)
	if err != nil {
		return err
	}
	defer in.Close()

	blocks, maxSeen, err := parseRawBlocks(in)
	if err != nil {
		return err
	}

	out, err := os.Create(outFn)
	if err != nil {
		return err
	}
	defer func() {
		e := out.Close()
		if err == nil {
			err = e
		}
	}()

	fmt.Fprintf(out, "// Code generated by %s; DO NOT EDIT.\n", filepath.Base(os.Args[0]))
	fmt.Fprintf(out, "\npackage %s\n\n", flags.packageName)
	fmt.Fprintf(out, "var allKnownBlocks = []BlockInfo{\n")

	for i := range blocks {
		fmt.Fprintf(out, "\tBlockInfo{Min: %d, Max: %d, Name: %q},\n", blocks[i].Min, blocks[i].Max, blocks[i].Name)
	}

	fmt.Fprintf(out, "}\n")
	fmt.Fprintf(out, "const maxKnownBlockRune = %d\n", maxSeen)
	return nil
}

func parseRawBlocks(in io.Reader) ([]unicode.BlockInfo, rune, error) {
	rdr := bufio.NewReader(in)
	ordered := make([]unicode.BlockInfo, 0, 500)
	matcher := regexp.MustCompile(`^([0-9A-Fa-f]+)\.\.([0-9A-Fa-f]+);\s+(\S.*?)\s*$`)

	var maxKnownBlockRune rune
	lineNum := 0
ReadLoop:
	for {
		line, err := rdr.ReadBytes('\n')
		lineNum++
		if err != nil {
			switch err {
			case io.EOF:
				break ReadLoop
			default:
				return nil, 0, err
			}
		}
		line = line[:len(line)-1]

		// our embedding inserts an extra newline at the start; be resistant
		if len(line) == 0 {
			continue
		}

		got := matcher.FindSubmatch(line)
		if got == nil {
			continue
		}

		bi := unicode.BlockInfo{
			Min:  aux.RuneFromHexField(got[1]),
			Max:  aux.RuneFromHexField(got[2]),
			Name: string(got[3]),
		}
		if bi.Max < maxKnownBlockRune {
			return nil, 0, fmt.Errorf("unsorted block info line %d got max %d which < %d", lineNum, bi.Max, maxKnownBlockRune)
		}
		// Trace("Found block %v", bi)
		maxKnownBlockRune = bi.Max
		ordered = append(ordered, bi)
	}

	return ordered, maxKnownBlockRune, nil
}

func reformatFile(fn string) error {
	cmd := exec.Command("go", "fmt", fn)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func haveDir(dirname string) bool {
	st, err := os.Stat(dirname)
	if err != nil {
		if !os.IsNotExist(err) {
			Warn("failed to stat %q: %s", dirname, err)
		}
		return false
	}
	if st.Mode().IsDir() {
		return true
	}
	Warn("not a directory: %q (%s)", dirname, st.Mode())
	return false
}

func Trace(template string, params ...interface{}) {
	fmt.Fprintf(os.Stderr, "%s: ", filepath.Base(os.Args[0]))
	fmt.Fprintf(os.Stderr, template, params...)
	fmt.Fprintln(os.Stderr)
}

func Warn(template string, params ...interface{}) {
	Trace(template, params...)
	warningCount++
}

func Die(template string, params ...interface{}) {
	Warn(template, params...)
	os.Exit(1)
}
